---
// src/layouts/Layout.astro
import "../styles/global.css";
export interface Props {
  title: string;
}
const { title } = Astro.props;
---

<!doctype html>
<html lang="es" class="m-0 p-0">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="light only" />
    <link rel="icon" type="image/svg+xml" href="/Coronadorada.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Crimson+Text:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Crimson+Text:wght@400;600;700&family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Charm:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* Forzar modo claro y evitar dark mode del navegador */
      html {
        width: 100%;
        height: 100%;
        overflow-x: hidden;
        color-scheme: light only;
      }

      body {
        margin: 0;
        padding: 0;
        width: 100%;
        min-height: 100vh;
        overflow-x: hidden;
        position: relative;
        color-scheme: light only;
      }

      /* Contenedor de fondos fijo */
      .background-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        overflow: hidden;
      }

      /* Imagen de fondo azul */
      .background-image {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url("/imagenes/fondoazul.webp");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        z-index: 1;
      }

      /* Canvas para video con chroma key */
      #particles-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: 2;
        pointer-events: none;
      }

      /* Video oculto (solo para procesamiento) */
      #particles-video {
        display: none;
      }

      main {
        background: transparent !important;
        position: relative;
        z-index: 10;
      }
    </style>
  </head>
  <body class="min-h-screen m-0 p-0">
    <!-- Contenedor de fondos -->
    <div class="background-container">
      <!-- Imagen de fondo azul -->
      <div class="background-image"></div>

      <!-- Canvas para mostrar video con chroma key -->
      <canvas id="particles-canvas"></canvas>

      <!-- Video oculto (loop automático) -->
      <video
        id="particles-video"
        autoplay
        loop
        muted
        playsinline
        preload="auto"
      >
        <source src="/video/particulas.mp4" type="video/mp4" />
      </video>
    </div>

    <main class="m-0 p-0 overflow-x-hidden">
      <slot />
    </main>

    <!-- Script para Chroma Key con Canvas -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const video = document.getElementById(
          "particles-video",
        ) as HTMLVideoElement;
        const canvas = document.getElementById(
          "particles-canvas",
        ) as HTMLCanvasElement;

        if (!video || !canvas) return;

        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (!ctx) return;

        let isProcessing = false;

        // Configurar canvas al tamaño de la ventana
        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        // Iniciar video
        video.play().catch((error) => {
          console.log("Error al reproducir video:", error);
        });

        // Procesar cada frame del video
        function processFrame() {
          // Continuar procesando siempre (removido el check de paused/ended)

          // Dibujar video en canvas
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

          // Obtener datos de imagen
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          // Remover verde (Chroma Key)
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            // Detectar verde y hacerlo transparente
            const isGreen =
              g > 90 && // Verde alto
              g > r * 1.5 && // Verde mayor que rojo
              g > b * 1.5; // Verde mayor que azul

            if (isGreen) {
              data[i + 3] = 0; // Hacer transparente
            }
          }

          // Aplicar imagen procesada
          ctx.putImageData(imageData, 0, 0);

          // Continuar procesando indefinidamente
          requestAnimationFrame(processFrame);
        }

        // Iniciar procesamiento cuando el video esté listo
        video.addEventListener("loadeddata", () => {
          if (!isProcessing) {
            isProcessing = true;
            processFrame();
          }
        });

        // Reiniciar video automáticamente al finalizar
        video.addEventListener("ended", () => {
          video.currentTime = 0;
          video.play().catch((error) => {
            console.log("Error al reiniciar video:", error);
          });
        });

        // Manejar errores de reproducción
        video.addEventListener("error", (e) => {
          console.error("Error en el video:", e);
        });

        // Asegurar reproducción continua cuando la página vuelve a estar visible
        document.addEventListener("visibilitychange", () => {
          if (!document.hidden && video.paused) {
            video.play().catch((error) => {
              console.log("Error al reanudar video:", error);
            });
          }
        });
      });
    </script>
  </body>
</html>
